import numpy as np

# 2. Основные типы данных. Создание массивов функцией array()

# Например сформируем одномерный массив целых чисел
# Если же нам явно нужно указать тип элементов массива, то его можно записать вторым аргументом, 'float64'
a = np.array([1, 2, 3, 4])
a = np.array([1, 2, 3, 4], 'float64')
print(a)
# [1. 2. 3. 4.]
# В результате все величины будут вещественными 64-битными числами, который занимает 8 байт в памяти компьютера

# И здесь сразу возникает вопрос: какие типы данных поддерживает пакет NumPy.
# Их огромное количество и посмотреть можно с помощью словаря sctypeDict:
print(np.sctypeDict)
# for i in np.sctypeDict:
#     print(i)

# Тип               Описание
#
# bool_               Логический тип (истина или ложь), хранящийся в виде байта.
#
# int_                Целочисленный тип установленный по умолчанию (такой же, как C long, как правило это либо int64 либо int32).
#
# intc                Идентичен C int (int32 или int64).
#
# intp                Целочисленный тип, используемый для индексирования (такой же, как C ssize_t, как правило это либо int64 либо int32).
#
# int8                Целые числа в диапазоне от -128 по 127 (числа размером 1 байт).
#
# int16               Целые числа в диапазоне от -32768 по 32767, (числа размером 2 байта).
#
# int32               Целые числа в диапазоне от -2147483648 по 2147483647, (числа размером 4 байта).
#
# int64               Целые числа размером 8 байт.
#
# uint8               Целые числа в диапазоне от 0 по 255 (числа размером 1 байт).
#
# uint16              Целые числа в диапазоне от 0 по 65535 (числа размером 2 байта).
#
# uint32              Целые числа в диапазоне от 0 по 4294967295 (числа размером 4 байта).
#
# uint64              Целые беззнаковыечисла размером 8 байт.
#
# float_              То же самое что и float64.
#
# float16             Вещественные числа половинной точности: 1 бит знака, 5 бит экспоненты, 10 бит мантисы (числа размером 2 байта).
#
# float32             Вещественные числа одинарной точности: 1 бит знака, 8 бит экспоненты, 23 бита мантисы (числа размером 4 байта).
#
# float64             Вещественные числа двойной точности: 1 бит знака, 11 бит экспоненты, 52 бита мантисы (числа размером 8 байт).
#
# complex_            То же самое что и complex128.
#
# complex64           Комплексные числа, в которых действительная и мнимая части представлены двумя вещественными числами типа float32.
#
# complex128          Комплексные числа, в которых действительная и мнимая части представлены двумя вещественными числами типа float64.
#
# str_                Для представления строк

# Например у нас в массиве будет 1000 элементов и у каждого int8, соответственно каждый элемент будет занимать 1 байт
# тогда весь массив памяти будет занимать 1000 байт
# 1000 элементов x int8 = 1000 байт
# 1000 элементов x int64 = 8000 байт
# На больших массивах нужно указывать тип данных

# Например мы создаем массив с типом 'uintc', тогда каждый элемент будет представляться беззнаковым целым
a1 = np.array([1, 2, 3, 4], 'uintc')
print(a1)
# [1 2 3 4]

# или тип строк str_
a2 = np.array([1, 2, 3, 4], 'str_')
print(a2)
# ['1' '2' '3' '4']

# типы данных можно использовать как отдельный самостоятельный объект - на выходе мы получаем комплексное число
# с помощью таких объектов мы можем выполнять преобразование типов целое в комплексное число
ex = np.complex64(10)
print(ex)
# (10+0j)

# преобразование, чтоб на выходе получить целое число которое будет представлено из 2 байт,
# необходимо выполнять осторожно т.к. это может привести к потере данных и их некорректному представлению
ex1 = np.int16(10.5)
print(ex1)
# 10

# например создадим массив с типом int8
ex2 = np.array([1, 2, 5000, 1000], dtype='int8')
print(ex2)
# [   1    2 -120  -24]
# 5000 и 1000 не умещаются в однобайтовое число - int8 это 1 байт и он не может хранить такие большие числа

# например, нужно выполнить преобразование типов массив complex чисел
ex3 = np.array([1, 2, 5000, 1000])
print(np.complex64(ex3))
# возвращается копия массива
# [1.e+00+0.j 2.e+00+0.j 5.e+03+0.j 1.e+03+0.j]
# исходный массив ex3 остается без изменений
print(ex3)
# [   1    2 5000 1000]

# присвоим массив переменной b
b = np.complex64(ex3)
print('array b: ', b)
# сделаем преобразование массива b, екоторый состоит из комплексных чисел в тип 'int32', отбросим мнимую часть
c = np.int32(b)
print('b-->c: ', c)
# При преобразовании типов от более общего к частному возможна потеря данных
# ComplexWarning: Casting complex values to real discards the imaginary part c = np.int32(b)
#                 Когда комплексное число преобразуется к целочисленному, возможна потеря данных
# При этом массив преобразуется успешно: [   1    2 5000 1000]


# array() - в качестве первого параметра можно указывать либо список [], либо кортеж ()
#           преобразования кортежа () также преобразуются в массив numpy
t = np.array((1, 2, 3))
print(t)

# Например, если в кортеж() в качестве первого параметра передаем строку "" из одного элемента
ex4 = np.array(("Hello", 'world'))
print(ex4)

# Например в двумерном массиве требуется определить матрицу размерностью 3х2, 3 - строки, 2 - столбца
# укажем внешний список[] и внутри вложенный список []
ex5 = np.array([[1, 2], [3, 4], [5, 6]])
print(ex5)
# [[1 2]
#  [3 4]
#  [5 6]]
# Двумерный массив должен быть задан в виде матрицы - а не np.array([[1, 2], [3, 4], [5, 6, 7]]) - неровномерный двумерный список
# Матрица должна содержать определенное колличество столбцов и строк, быть прямоугольной таблицей из чисел
# VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated.
# If you meant to do this, you must specify 'dtype=object' when creating the ndarray.

# Трехмерная матрица - [[[ - первая размерность, вторая размерность, вложенные списки
ex6 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])
print(ex6)
# [[[ 1  2]
#   [ 3  4]]
#  [[ 5  6]
#   [ 7  8]]
#  [[ 9 10]
#   [11 12]]]
# Как располагаются оси многомерных массивов? вдоль первой оси для трехмерного массива axis0 ------------>
#                                             будут располагаться двумерные срезы матрицы      |  |  |
#                                             axis1 axis - будут определять строки и столбцы двумерных срезов
# двумерная матрица - первый двумерный срез
print(ex6[0])
# [[1 2]
#  [3 4]]

# второй двумерный срез
print(ex6[1])
# [[5 6]
#  [7 8]]

# Укажем два индекса для получения первой строки первого среза: axis1 - первая строка с индексом 0, axis2 - значения 1 и 2
#      0        0         1       1         2         2               - index - axis 0
#      0        1         0       1         0         1               - axis
#     0  1    0  1      0  1    0  1      0   1    0   1              - axis
# ([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])
#

print(ex6[0, 0])
# [1 2]

# Получим самый первый элемент трехмерной матрицы
print(ex6[0, 0, 0])
# 1

# Получим  второй элемент третьей строки трехмерной матрицы
print(ex6[2, 0, 1])
#

# Так можно обращаться к срезам, к строкам, либо к конкретным элементам трехмерной матрицы