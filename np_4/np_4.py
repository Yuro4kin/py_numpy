import numpy as np

# 4. Свойства и представления массивов, создание их копий

# Поведение массивов numpy при изменении типов данных
# Например у нас есть следующий массив m
m = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
print(m)
# [0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]
# Через точку будут доступны методы и свойства класса array()
# m.
# Свойство .dtype возвратит текущий тип элементов массива 'float64' - 8 байт
print(m.dtype)
# float64

# Поменяем тип данных массива m и присвоим ему 'int8'-1бит путем создания нового объекта
# в результате массив m поменяет свой тип, проверим теперь значения массива - стало 72 элемента
# каждый элемент, который занимал 8 байт, стал представляться 8 числами (-102 -103 -103 -103 -103 -103  -71)
# следовательно число элементов увеличилось в 8 раз 9*8=72, потери данных не произошло
# как было в памяти 72 байта так и занимает 72 байта
m.dtype = np.int8()
print(m)
# [-102 -103 -103 -103 -103 -103  -71   63 -102 -103 -103 -103 -103 -103
#   -55   63   51   51   51   51   51   51  -45   63 -102 -103 -103 -103
#  -103 -103  -39   63    0    0    0    0    0    0  -32   63   51   51
#    51   51   51   51  -29   63  102  102  102  102  102  102  -26   63
#  -102 -103 -103 -103 -103 -103  -23   63  -51  -52  -52  -52  -52  -52
#   -20   63]

# size() - свойство проверки размера массива m
print(m.size)
# 72

# если мы вернем прежний тип данных 'float'64, то увидим прежнее значение
m.dtype = np.float64()
print(m)
# [0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]

# присвоим тип массиву m в виде заданной строки 'float32' - в два раза меньше, чем 'float64'
m.dtype = 'float32'
print(m)
# [-1.58818684e-23  1.44999993e+00 -1.58818684e-23  1.57499993e+00
#   4.17232506e-08  1.64999998e+00 -1.58818684e-23  1.69999993e+00
#   0.00000000e+00  1.75000000e+00  4.17232506e-08  1.77499998e+00
#   2.72008302e+23  1.79999995e+00 -1.58818684e-23  1.82499993e+00
#  -1.07374184e+08  1.84999990e+00]

# size() - свойство проверки размера массива m
print(m.size)
# 18

# Например, ребуется узнать, сколько байт занимает один элемент в массиве,
# 'float32' занимает 4 байта в памяти ПК
print(m.itemsize)
# 4

# вернем исходный тип 'float64', который занимает 8 байт в памяти ПК
m.dtype = 'float64'
print(m.itemsize)
# 8

# Например вычислим размер всего массива m в байтах
# .size число элементов * .itemsize размер байт занимаемый 1 элементом = 72 байта
print(m.size * m.itemsize)

# создадим массив свойством размерностью (3, 4, 5) состоящий из всех 1
# Вопрос, как узнать колличество его осей, т.е. его размеррность?
m1 = np.ones((3, 4, 5))
print(m1)
# [[[1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1.]]
#
#  [[1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1.]]
#
#  [[1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1.]]]

# Узнаем размерность массива .ndim, размерность равна 3
print(m1.ndim)

# Например мы хотим узнать число элементов по каждой из оси
# для этого св-во .shape, которое возвращает кортеж из элементов по каждой оси
print(m1.shape)
# (3, 4, 5)

# .shape - можно менять и размерность массива, но главное чтоб число элементов оставалось прежним
# 4 * 5 = 20 * 3 = 60 - всего элементов, эта размерность присваивается массиву
# теперь массив m1 стал одномерный и содержит 60 единиц
m1.shape = 60
print(m1)
# [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.
#  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.
#  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]

# присвоим кортеж, массив будет размерностью 12х5 элементов, двумерный
m1.shape = 12, 5
print(m1)
# [[1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1.]]

# .shape - свойство которое меняет представление текущих данных одного и того же массива
#          новые массивы не создавались, менялось представление текущего массива
#          один и тот же массив может иметь разные представления

# сформируем новый массив m2 на основе массива m1, просто изменив его форму
m2 = m1.reshape(3, 2, 10)
print(m2)
# [[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
#
#  [[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
#
#  [[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
#   [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]]

# переменная m1 продолжает ссылаться на свое представление
# m1, m2 - ссылаются на представления одних и тех же данных
#           12 x 5       --- m1
# np.array
#           3 x 2 x 10   --- m2
print(m1)

# проверка - заменим первый элемент массива m1 на 10
m1[0, 0] = 10
print(m1)
# [[10.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.]]

# также поменялось значение элемента в массиве m2
print(m2)
# [[[10.  1.  1.  1.  1.  1.  1.  1.  1.  1.]
#   [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]]
#
#  [[ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]
#   [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]]
#
#  [[ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]
#   [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]]]

# id - разные, т.к. ссылаются на разные представления, за этими представлениями скрываются одинаковые данные
print(id(m1), id(m2))
# 2275093077808 2275093127312

# функция reshape() не создает нового массива, а создает новое представление тех же данных, котрые были изначально
# один и тот же массив можно использовать и как одномерный вектор, и как матрицу ( экономия памяти ПК)

# Например, создадим представление с помощью метода .T транспонирования матрицы
#           при этом представление массиа m1 не изменилось размерами 12х5
m3 = m1.T
print(m3)
# [[10.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]
#  [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]]

# Например, узнаем когда в программе создается новый независимый массив, а когда его представление
#           любое изменение формы связано с новым представлением
# view() - метод который существует у каждого массива, возвращает копию его представления

# Например мы создаем одномерный массив m4, далее на массив m4 ссылается переменная m5,
# m4, m5 - ссылаются на один одномерный массив, копирования не происходит
#          если мы изменим преставление массива m4, то это повлияет на отображение массива m5
m4 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
m5 = m4
m4.shape = 3, 3
print(m4,"\n", m5)
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
#  [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
# Может быть ERROR в больших проектах, программист на входе функции ожидает вектор, а получает матрицу
# для этого есть проверка, создать новое представление начального массива с помощью метода view()
# должны присвоить копию представления этого массива
# Например
m6 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
m7 =m6.view() #создается копия представления
print(m6,"\n", m7)
# [1 2 3 4 5 6 7 8 9]
#  [1 2 3 4 5 6 7 8 9]

# Поменяем размерность(представление) массива m6 3x3, что не сказывается на размерности(представлении)  массиве m7
# Защита программиста от ошибок
m6.shape = 3, 3
print(m6,"\n", m7)
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
#  [1 2 3 4 5 6 7 8 9]

# Например нам нужно создать копию всего массива, данных. m9 будет ссылаться на копию массива m8
# При изменении первого элемента массива m8, это не повлияет на копию массива m9
m8 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
m9 = np.array(m8)
m8[0] = 100
print(m8, m9)
# [100   2   3   4   5   6   7   8   9] [1 2 3 4 5 6 7 8 9]

# copy() - метод, теперь массив m10 будет ссылаться на копию, сделаем второй элемент равен 1, то
#          массив m8 у нас остался прежним
m10 = m8.copy()
m10[1] = 1
print(m8, m10)
#  m8                                   m10        |
# [100   2   3   4   5   6   7   8   9]     [100   1   3   4   5   6   7   8   9]